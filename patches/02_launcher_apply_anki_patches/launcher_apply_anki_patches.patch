diff -ruN '--exclude=Cargo.lock' '--exclude=out' '--exclude=target' original/qt/launcher/Cargo.toml v1_edit/qt/launcher/Cargo.toml
--- original/qt/launcher/Cargo.toml	2025-11-16 20:09:05.984661252 +0100
+++ v1_edit/qt/launcher/Cargo.toml	2025-11-16 20:09:48.237641983 +0100
@@ -14,6 +14,7 @@
 camino.workspace = true
 dirs.workspace = true
 serde_json.workspace = true
+diffy = "0.4"
 
 [target.'cfg(all(unix, not(target_os = "macos")))'.dependencies]
 libc.workspace = true
diff -ruN '--exclude=Cargo.lock' '--exclude=out' '--exclude=target' original/qt/launcher/src/main.rs v1_edit/qt/launcher/src/main.rs
--- original/qt/launcher/src/main.rs	2025-11-16 20:09:05.986107404 +0100
+++ v1_edit/qt/launcher/src/main.rs	2025-11-16 20:09:48.237400854 +0100
@@ -29,6 +29,7 @@
 use crate::platform::respawn_launcher;
 
 mod platform;
+mod patch;
 
 struct State {
     current_version: Option<String>,
@@ -349,6 +350,12 @@
                 }
             }
 
+            // Apply custom patches after successful installation
+            if let Err(e) = patch::apply_patches(&state.venv_folder) {
+                println!("Warning: Failed to apply patches: {e:#}");
+                println!("Anki will continue without patches.");
+            }
+
             Ok(())
         }
         Err(e) => {
diff -ruN '--exclude=Cargo.lock' '--exclude=out' '--exclude=target' original/qt/launcher/src/patch.rs v1_edit/qt/launcher/src/patch.rs
--- original/qt/launcher/src/patch.rs	1970-01-01 01:00:00.000000000 +0100
+++ v1_edit/qt/launcher/src/patch.rs	2025-11-18 20:53:59.887737519 +0100
@@ -0,0 +1,159 @@
+use std::path::{Path, PathBuf};
+use anki_io::{read_file, write_file, copy_file};
+use anyhow::{Context, Result};
+use diffy::{Patch, apply};
+
+/// Apply patches to the installed Anki files
+pub fn apply_patches(venv_folder: &Path) -> Result<()> {
+    println!("Applying custom patches...");
+
+    let patches_dir = get_patches_directory()?;
+    if !patches_dir.exists() {
+        println!("No patches directory found, skipping patch application.");
+        return Ok(());
+    }
+
+    // List of patches to apply in order
+    let patch_files = [
+        "anki_qt_window_lib_main.patch",
+        "anki_qt_window_lib_webview.patch",
+        "anki_qt_window_lib64_main.patch",
+        "anki_qt_window_lib64_webview.patch",
+        "anki_branding.patch",
+    ];
+
+    for patch_file in &patch_files {
+        let patch_path = patches_dir.join(patch_file);
+        if patch_path.exists() {
+            println!("Applying patch: {}", patch_file);
+            apply_single_patch(&patch_path, venv_folder)
+                .with_context(|| format!("Failed to apply patch: {}", patch_file))?;
+        } else {
+            println!("Patch not found, skipping: {}", patch_file);
+        }
+    }
+
+    println!("Patch application completed successfully.");
+    Ok(())
+}
+
+/// Get the patches directory relative to the launcher binary
+fn get_patches_directory() -> Result<PathBuf> {
+    let exe_path = std::env::current_exe()
+        .context("Failed to get current executable path")?;
+    let exe_dir = exe_path.parent()
+        .context("Failed to get executable directory")?;
+    Ok(exe_dir.join("patches"))
+}
+
+/// Apply a single patch file to the venv
+fn apply_single_patch(patch_path: &Path, venv_folder: &Path) -> Result<()> {
+    // Read the patch file
+    let patch_content = read_file(patch_path)?;
+    let patch_str = String::from_utf8(patch_content)
+        .context("Patch file contains invalid UTF-8")?;
+
+    // Note: diffy parses patches as single-file patches
+    // For multi-file patches, we'd need to split them first
+    // Currently our patches (anki_qt_window.patch, anki_branding.patch) are single-file
+
+    // Parse the patch using diffy
+    let patch = Patch::from_str(&patch_str)
+        .context("Failed to parse patch file")?;
+
+    // Get the target file path from the patch
+    // diffy uses the +++ line (modified) if present, otherwise --- line (original)
+    let target_path = patch.modified()
+        .or_else(|| patch.original())
+        .context("Patch doesn't specify a file path")?;
+
+    // Apply our -p1 path stripping and resolve to venv path
+    let file_path = resolve_patch_path(target_path, venv_folder)?;
+
+    if !file_path.exists() {
+        println!("Warning: Target file does not exist, skipping: {}", file_path.display());
+        return Ok(());
+    }
+
+    // Create backup before applying patch
+    let backup_path = create_backup(&file_path)?;
+
+    // Read the original file
+    let original_content = read_file(&file_path)?;
+    let original_str = String::from_utf8(original_content)
+        .context("Original file contains invalid UTF-8")?;
+
+    // Apply the patch using diffy's apply function
+    match apply(&original_str, &patch) {
+        Ok(patched_content) => {
+            // Write the patched content
+            write_file(&file_path, &patched_content)?;
+            println!("Successfully patched: {}", file_path.display());
+        }
+        Err(e) => {
+            // Restore backup on failure
+            copy_file(&backup_path, &file_path)?;
+            println!("Failed to apply patch to {}: {}", file_path.display(), e);
+            println!("Original file restored from backup.");
+        }
+    }
+
+    Ok(())
+}
+
+
+/// Resolve patch file path to actual file system path
+fn resolve_patch_path(patch_path: &str, venv_folder: &Path) -> Result<PathBuf> {
+    // Implement -p1: strip first directory component (generic path stripping)
+    let clean_path = if let Some(slash_pos) = patch_path.find('/') {
+        &patch_path[slash_pos + 1..]  // Take everything after first /
+    } else {
+        patch_path  // No slash found, use as-is
+    };
+
+    // Strip .venv/ prefix if present (since venv_folder already contains it)
+    let clean_path = clean_path.strip_prefix(".venv/").unwrap_or(clean_path);
+
+    // Build the full path relative to venv
+    let full_path = venv_folder.join(clean_path);
+
+    Ok(full_path)
+}
+
+/// Create a backup of the file before patching
+fn create_backup(file_path: &Path) -> Result<PathBuf> {
+    let backup_path = file_path.with_extension(
+        format!("{}.backup",
+                file_path.extension()
+                    .and_then(|s| s.to_str())
+                    .unwrap_or(""))
+    );
+
+    copy_file(file_path, &backup_path)?;
+    Ok(backup_path)
+}
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+
+    #[test]
+    fn test_resolve_patch_path() {
+        let venv = PathBuf::from("/tmp/venv");
+
+        assert_eq!(
+            resolve_patch_path("a/src/main.py", &venv).unwrap(),
+            PathBuf::from("/tmp/venv/src/main.py")
+        );
+
+        assert_eq!(
+            resolve_patch_path("b/lib/aqt/__init__.py", &venv).unwrap(),
+            PathBuf::from("/tmp/venv/lib/aqt/__init__.py")
+        );
+
+        assert_eq!(
+            resolve_patch_path("src/main.py", &venv).unwrap(),
+            PathBuf::from("/tmp/venv/src/main.py")
+        );
+    }
+}
\ No newline at end of file
